#  File converted from Magma code -- requires editing and checking
#  Magma -> GAP converter, version 0.43, 4/04/16 by AH

#  Global Variables used: A7, Append, Center, Centraliser, Centre, Classes,
#  CorrectForm, DerivedSubgroup, DiagonalMatrix, FPGroupStrong, Factorisation,
#  FreeGroup, GF, GL, GU, Gcd, Generators, Getsl27d4, GtoSU, Id, Integers,
#  IsAbsolutelyIrreducible, IsConjugate, IsCyclic, IsEven, IsIsomorphic, IsOdd,
#  IsPrime, IsPrimitive, IsSemiLinear, IsSquare, IsTensor, L3_4,
#  MakeSU4HomomGeneral, Matrix, Ngens, NormalSubgroups, OrbitAction, Order,
#  PCGroup, PGU, PGammaU, PSU, PSigmaU, PrimitiveElement, RSpace, Random,
#  RandomSchreier, RecogniseSU4, SL, SU, SigmaGrp, Socle, SquareRoot,
#  Stabiliser, Subgroups, SylowSubgroup, TransformForm, U4_2, U4pIdentify,
#  UnitaryForm, WhichGroup, homom

#  Defines: A7, Getsl27d4, L3_4, MakeHomom, MakeSU4HomomGeneral, SigmaGrp,
#  U4_2, U4pIdentify, U4qIdentify, WhichGroup

DeclareGlobalFunction("U4qIdentify@");

DeclareGlobalFunction("MakeSU4HomomGeneral@");

#  
#  * This file MUST be rechecked when constructive recognition is put in
#  for higher values of q, it currently only runs for q = 4,5,7

#  
#  This file contains the functions for computing maximal subgroups of
#  any almost simple group with socle PSU(4, p^e), p^e>2 and either $e$
#  is even or $e = 1$ or $p = 2$. This covers all groups whose minimal
#  degree representation is of degree less than 10^7.
#  In the prime case we distinguish between the following extensions:
#  
#  (p+1, 4) = 2: Here out = 2^2, we have "psu", "pgu", "psigmau" and
#  "aut" only: the group PSU.2_3 has the same subgroup conjugacy as PGU,
#  so we do not bother distinguishing between them.
#  
#  (p+1, 4) = 4: Here Out = D_8. We have
#  "psu",
#  "psu.2_1" (this is half of PGU), "psigmau", "psu.2_3" (the
#  outer element here is a product of .2_2 with the element that extends from
#  psu to pgu) : all of these extensions have order 2.
#  "pgu", "psu.2_12", "psu.2_13": these are extensions of order 4. the
#  second two both have a 2^2 on the outside. In the first case it is
#  generated by <.2_1, .2_2> and in the second by <.2_1, 2_3>.
#  "aut";
#  
#  If (q neq p) and q is even then we simply have type "psu".
#  
#  If (q \neq p) and (4, q+1) = 2 then we have types "psu" and "aut":
#  if $PSU \leq G \leq PSigmaU$ then type is "psu"; otherwise it's "aut".
#  
#  If (q \neq p) and (4, q+1) = 4 then there are four types: "psu",
#  "twoorth+", "twoorth-" and "aut". "twoorth+" groups are $G$ st $PSU.2_1
#  < G \leq PSU.<2_1, 2_2>$. "twoorth-" group are $G$ st $PSU.2_1 < G \leq
#  PSU.<2_1, 2_2*4^{-1}>.
#  
#  /******************************************************************
#  function names:
#  A7(p)
#  Getsl27d4
#  U4_2(p)
#  L3_4()
#  SigmaGrp(extension, p, e)
#  WhichGroup(group, p, e)
#  U4pMaximals(group, p)
#  U4qMaximals(group, q)
#  ******************************************************************
#  ******************************************************************
#  * 2.Alt(7) is a maximal C_9 group of SU(4, p) for p gt 7 and       *
#  * -7 a nonsquare in GF(p)                                          *
#  ******************************************************************
A7@:=function(p)
local C,D,G,b7,f,grp,i7,is_unitary,mat1,mat2,sl,x,y;
  Assert(1,IsPrimeInt(p));
  if p=3 then
    grp:=SubMatrixGroup(4,GF(3,2)
     ,[[W^2,W^7,2,W^7,W^7,W,W^2,W^6,W^2,W,2,W^5,W^5,W^3,W^2,W^6]
     ,[W^5,0,W^3,W^7,W^7,W^3,W,W^5,W^7,W^5,W^2,1,1,2,W^3,2]]);
    #  POSTPONED `where'
    W:=GF(3,2).1;
    #  POSTPONED `where'
    W:=GF(3,2).1;
    #   order = 10080 = 2^5 * 3^2 * 5 * 7 
    return grp;
  fi;
  if p=5 then
    grp:=SubMatrixGroup(4,GF(5,2)
     ,[[0,W^4,0,W^15,W^14,0,W^9,0,W^17,W^15,4,W^8,W^9,W,W^10,4]
     ,[W^3,1,W^2,W^21,W^13,1,0,0,W^22,W^20,W^15,W^17,4,2,W^23,3]]);
    #  POSTPONED `where'
    W:=GF(5,2).1;
    #  POSTPONED `where'
    W:=GF(5,2).1;
    #   order = 5040 = 2^4 * 3^2 * 5 * 7 
    return grp;
  fi;
  Assert(1,not IsSquare(-7 #CAST GF(p)
    ));
  Assert(1,p > 7);
  sl:=SL(4,p^2);
  i7:=SquareRoot((-7) #CAST GF(p^2)
    );
  b7:=((-1+i7)/2) #CAST GF(p^2)
    ;
  x:=((i7+3)/4) #CAST GF(p^2)
    ;
  y:=(b7/2) #CAST GF(p^2)
    ;
  C:=[0,0,1,0,0,0,0,1,-1,0,-1,0,0,-1,0,-1] #CAST sl
    ;
  D:=[0,-x,x,-y,-y,y,-y,0,-y,0,(-i7-1)/2,-x,0,-y,y,y] #CAST sl
    ;
  G:=SubStructure(sl,C,#TODO CLOSURE
    D);
  # =v= MULTIASSIGN =v=
  f:=UnitaryForm(G);
  is_unitary:=f.val1;
  f:=f.val2;
  # =^= MULTIASSIGN =^=
  Assert(1,is_unitary);
  mat1:=CorrectForm(f,4,p^2,"unitary");
  mat2:=CorrectForm(MatrixByEntries(GF(p^2)
   ,4,4,[0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0]),4,p^2,"unitary");
  return G^(mat1*mat2^-1);
end;
;
#  ********************************************************************
Getsl27d4@:=function(p)
local L,_LR,bool,c9,f1,mat;
  _LR:=rec(F:=FreeGroup(2));
  _LR.AI:=[[a^-1,b^-1]];
  #  POSTPONED `where'
  b:=(_LR.F).2;
  #  POSTPONED `where'
  a:=(_LR.F).1;
  #  two constituents interchanged by _LR`AI[1][1]
  _LR.G:=SubStructure(GL(8,Integers()),[[0,1,0,0,0,0,0,0],[-1,0,0,0,0,0,0,0]
   ,[0,0,0,1,0,0,0,0],[0,0,-1,0,0,0,0,0],[0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,1]
   ,[0,0,0,0,-1,0,0,0],[0,0,0,0,0,-1,0,0]]
,#TODO CLOSURE
    [[1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0],[0,0,0,0,0,1,0,0]
   ,[0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,-1],[0,0,0,0,0,0,1,0],[0,0,0,-1,0,0,0,0]]
);
  L:=ReduceOverFiniteField@(_LR,p^2);
  c9:=L[1];
  #  just testing this for now, delete later.
  Assert(1,IsAbsolutelyIrreducible(c9) and (not IsSemiLinear(c9)) and 
   IsPrimitive(c9) and (not IsTensor(c9)));
  # =v= MULTIASSIGN =v=
  f1:=UnitaryForm(c9);
  bool:=f1.val1;
  f1:=f1.val2;
  # =^= MULTIASSIGN =^=
  Assert(1,bool);
  mat:=TransformForm(c9);
  return c9^mat;
end;
;
#  **********************************************************************
#  
#  * We find a maximal C_9 subgroup isomorphic to U_(4, 2) = Sp(4, 3)
#  * whenever the p+1 mod 3 eq 0.

U4_2@:=function(p)
local a,b,c,f,f1,f2,g1,g2,gamma,grp,is_unitary,m1,m2,newgrp,omega;
  Assert(1,IsPrimeInt(p));
  #  assert p gt 3;
  Assert(1,(p+1) mod 3=0);
  gamma:=PrimitiveElement(GF(p^2));
  omega:=gamma^(QuoInt((p^2-1),3));
  g1:=((2+omega)/3) #CAST GF(p^2)
    ;
  g2:=((1-omega)/3) #CAST GF(p^2)
    ;
  f1:=((1+2*omega^2)/3) #CAST GF(p^2)
    ;
  f2:=((1-omega^2)/3) #CAST GF(p^2)
    ;
  a:=DiagonalMat([1,1,omega,1]) #CAST GL(4,p^2)
    ;
  b:=[1,0,0,0,0,f1,f2,f2,0,f2,f1,f2,0,f2,f2,f1] #CAST GL(4,p^2)
    ;
  c:=[g1,0,-g2,g2,0,1,0,0,-g2,0,g1,g2,g2,0,g2,g1] #CAST GL(4,p^2)
    ;
  grp:=SubStructure(GL(4,p^2),a,#TODO CLOSURE
    b,c);
  newgrp:=DerivedSubgroup(grp);
  Assert(1,Size(newgrp)=51840);
  # =v= MULTIASSIGN =v=
  f:=UnitaryForm(newgrp);
  is_unitary:=f.val1;
  f:=f.val2;
  # =^= MULTIASSIGN =^=
  Assert(1,is_unitary);
  m1:=CorrectForm(f,4,p^2,"unitary");
  m2:=CorrectForm(MatrixByEntries(GF(p^2),4,4,[0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0])
   ,4,p^2,"unitary");
  return newgrp^(m1*m2^-1);
end;
;
#  **********************************************************************
#  Maximal C_9 of U_4(3).
L3_4@:=function()
local g;
  g:=SubMatrixGroup(4,GF(3,2),[[0,2,0,W^6,0,W^3,0,1,W^2,W^7,2,W^7,W^3,1,W^6,W]
   ,[W^7,2,W^3,W^6,W^2,2,W^6,0,W^2,0,2,0,W^7,W^2,W,2]]);
  #  POSTPONED `where'
  W:=GF(3,2).1;
  #  POSTPONED `where'
  W:=GF(3,2).1;
  #   order = 80640 = 2^8 * 3^2 * 5 * 7 
  return g;
end;
;
#  **********************************************************************
SigmaGrp@:=function(extension,p,e)
local biggrp,norms;
  biggrp:=PSigmaU(4,p^e);
  norms:=NormalSubgroups(biggrp:OrderEqual:=Size(PSU(4,p^e))*extension);
  Assert(1,Size(norms)=1);
  return norms[1].subgroup;
end;
;
#  *******************************************************************
WhichGroup@:=function(group,p,e)
local 
   a,b,cl_2_1,cl_grp,cl_sig,d,data,data_grp,data_sig,f,i,out,p,pc_s2_pgu,pcs2,
   psu2_1,q,s2,s2_2_1,s2_pgu,s2_sigma,s2sig,s2sigma,sigmagrp,soc,subs,type;
  Assert(1,e=1 or IsEvenInt(e) or IsEvenInt(p));
  q:=p^e;
  soc:=Socle(group);
  if group=soc then
    return rec(val1:=group,
      val2:="psu");
  fi;
  d:=Gcd(q+1,4);
  if d=1 then
    Assert(1,IsEvenInt(p) and e > 1);
    return rec(val1:=soc,
      val2:="psu");
  fi;
  # =v= MULTIASSIGN =v=
  f:=Subquo(group,[soc]);
  out:=f.val1;
  f:=f.val2;
  # =^= MULTIASSIGN =^=
  if Size(out)=d*e*2 then
    return rec(val1:=soc,
      val2:="aut");
  fi;
  if e=1 and d=2 then
    Assert(1,Size(out)=2);
    #  owise have psu or aut(psu)
    s2:=SylowSubgroup(group,2);
    s2_sigma:=SylowSubgroup(PSigmaU(4,q),2);
    if Size(Center(s2))=Size(Centre(s2_sigma)) then
      #  I think this is the
      #  cheapest reliable test.
      return rec(val1:=soc,
        val2:="psigmau");
    else
      s2_pgu:=SylowSubgroup(PGU(4,q),2);
      pcs2:=PCGroup(s2);
      pc_s2_pgu:=PCGroup(s2_pgu);
      # =v= MULTIASSIGN =v=
      b:=IsIsomorphic(pcs2,pc_s2_pgu);
      a:=b.val1;
      b:=b.val2;
      # =^= MULTIASSIGN =^=
      if a then
        return rec(val1:=soc,
          val2:="pgu");
      else
        return rec(val1:=soc,
          val2:="psu.2_3");
      fi;
    fi;
  fi;
  if e=1 and d=4 then
    if Size(out)=2 then
      s2:=SylowSubgroup(group,2);
      s2sig:=SylowSubgroup(PSigmaU(4,q),2);
      cl_grp:=Classes(s2);
      cl_sig:=Classes(s2sig);
      data:=List([1..Size(cl_grp)],i->[cl_grp[i][1],cl_grp[i][2]]);
      if data=List([1..Size(cl_sig)],i->[cl_sig[i][1],cl_sig[i][2]]) then
        return rec(val1:=soc,
          val2:="psigmau");
      fi;
      # =v= MULTIASSIGN =v=
      psu2_1:=OrbitAction(SubStructure(GL(4,q^2),SU(4,q),#TODO CLOSURE
        (GU(4,q).1)^2),SubStructure(RSpace(GL(4,q^2)),[1,0,0,0]));
      p:=psu2_1.val1;
      psu2_1:=psu2_1.val2;
      # =^= MULTIASSIGN =^=
      s2_2_1:=SylowSubgroup(psu2_1,2);
      cl_2_1:=Classes(s2_2_1);
      if data=List([1..Size(cl_2_1)],i->[cl_2_1[i][1],cl_2_1[i][2]]) then
        return rec(val1:=soc,
          val2:="psu.2_1");
      else
        return rec(val1:=soc,
          val2:="psu.2_3");
      fi;
    fi;
    Assert(1,Size(out)=4);
    if IsCyclic(out) then
      return rec(val1:=soc,
        val2:="pgu");
    fi;
    subs:=Subgroups(out:OrderEqual:=2);
    Assert(1,Size(subs)=3);
    for i in [1..3] do
      # =v= MULTIASSIGN =v=
      type:=WhichGroup@(subs[i].subgroup@@f,p,e);
      soc:=type.val1;
      type:=type.val2;
      # =^= MULTIASSIGN =^=
      if "psigmau"=type then
        return rec(val1:=soc,
          val2:="psu.2_12");
      elif "psu.2_3"=type then
        return rec(val1:=soc,
          val2:="psu.2_13");
      fi;
    od;
  fi;
  Assert(1,e > 1 and IsOddInt(p));
  if d=2 then
    if IsOddInt(e) then
      if IsOddInt(Size(out)) then
        return rec(val1:=soc,
          val2:="psu");
        #  has same fusion as psu;
      else
        return rec(val1:=soc,
          val2:="aut");
        #  has same fusion as aut;
      fi;
    fi;
    if not IsCyclic(out) then
      return rec(val1:=soc,
        val2:="aut");
    fi;
    sigmagrp:=SigmaGrp@(Size(out),p,e);
    s2:=SylowSubgroup(group,2);
    s2sigma:=SylowSubgroup(sigmagrp,2);
    Assert(1,Size(s2)=Size(s2sigma));
    cl_grp:=Classes(s2);
    cl_sig:=Classes(s2sigma);
    data_grp:=List([1..Size(cl_grp)],i->[cl_grp[i][1],cl_grp[i][2]]);
    data_sig:=List([1..Size(cl_sig)],i->[cl_sig[i][1],cl_sig[i][2]]);
    if data_grp=data_sig then
      return rec(val1:=soc,
        val2:="psu");
    else
      return rec(val1:=soc,
        val2:="aut");
    fi;
  fi;
  Info(InfoWarning,1,
    "error: we should have PSU(4, p) or PSU(4, 2^e) or PSU(4, p^e)");
  Info(InfoWarning,1,"where e is even");
  return rec(val1:=0,
    val2:=_);
end;
;
#  Homomorphism function - currently only works for q=4,5,7.
#  can hopefully use Brooksbank's method for other  q  later.
MakeHomom@:=function(group,q,psu,apsu)
local 
   CG,GtoPSU,GtoSU,Print,a,a1,b,b1,ce,found,g,group,h,homom,i,imconj,imgens,ims,
   isc,j,newgens,o,psugens,soc,socle,subgp,subsoc;
  Print:=ValueOption("Print");
  if Print=fail then
    Print:=0;
  fi;
  soc:=Socle(group);
  #   find standard generators in soc and in psu if the different cases.
  if q=4 then
    o:=1;
    while o<>20 and o<>30 do
      a:=Random(soc);
      o:=Order(a);
    od;
    a:=a^(QuoInt(o,2));
    found:=false;
    while not found do
      o:=1;
      while o<>4 do
        b:=Random(soc);
        o:=Order(b);
      od;
      for i in [1..50] do
        if Order(a*b)=20 then
          found:=true;
          break;
        fi;
        b:=b^Random(soc);
      od;
    od;
    o:=1;
    while o<>20 and o<>30 do
      a1:=Random(psu);
      o:=Order(a1);
    od;
    a1:=a1^(QuoInt(o,2));
    found:=false;
    while not found do
      o:=1;
      while o<>4 do
        b1:=Random(psu);
        o:=Order(b1);
      od;
      for i in [1..50] do
        if Order(a1*b1)=20 then
          found:=true;
          break;
        fi;
        b1:=b1^Random(psu);
      od;
    od;
  elif q=5 then
    o:=1;
    while o<>8 and o<>24 and o<>60 do
      a:=Random(soc);
      o:=Order(a);
    od;
    b:=a^(QuoInt(o,4));
    a:=a^(QuoInt(o,2));
    while Order(a*b)<>9 do
      b:=b^Random(soc);
    od;
    o:=1;
    while o<>8 and o<>24 and o<>60 do
      a1:=Random(psu);
      o:=Order(a1);
    od;
    b1:=a1^(QuoInt(o,4));
    a1:=a1^(QuoInt(o,2));
    while Order(a1*b1)<>9 do
      b1:=b1^Random(psu);
    od;
  elif q=7 then
    o:=1;
    while o<>56 and o<>48 do
      a:=Random(soc);
      o:=Order(a);
    od;
    b:=a^(QuoInt(o,4));
    a:=a^(QuoInt(o,2));
    while Order(a*b)<>15 or Order(Tuple([a,b]))<>24 do
      b:=b^Random(soc);
    od;
    o:=1;
    while o<>56 and o<>48 do
      a1:=Random(psu);
      o:=Order(a1);
    od;
    b1:=a1^(QuoInt(o,4));
    a1:=a1^(QuoInt(o,2));
    while Order(a1*b1)<>15 or Order(Tuple([a1,b1]))<>24 do
      b1:=b1^Random(psu);
    od;
  fi;
  newgens:=[a,b];
  soc:=SubStructure(soc,newgens);
  subgp:=soc;
  for g in Generators(group) do
    if not g in subgp then
      Add(newgens,g);
      subgp:=SubStructure(group,newgens);
      RandomSchreier(subgp);
    fi;
  od;
  group:=subgp;
  GtoSU:=GroupHomomorphismByImages(soc,psu,
    a1,b1);
  psugens:=[a1,b1];
  #  Now identify images of all generators of group in apsu.
  ims:=psugens;
  for i in [Ngens(soc)+1..Ngens(group)] do
    g:=group.i;
    CG:=apsu;
    ce:=One(apsu);
    for j in [1..Size(psugens)] do
      imconj:=GtoSU(soc.j^g);
      # =v= MULTIASSIGN =v=
      h:=IsConjugate(CG,psugens[j]^ce,imconj);
      isc:=h.val1;
      h:=h.val2;
      # =^= MULTIASSIGN =^=
      if not isc then
        Error("Conjugation error in Aut(PSU(d,q))");
      fi;
      CG:=Centraliser(CG,imconj);
      ce:=ce*h;
    od;
    Add(ims,ce);
  od;
  return rec(val1:=GroupHomomorphismByImages(group,apsu,
    GeneratorsOfGroup(group),ims),
    val2:=soc,
    val3:=group);
end;
;
#  **********************************************************************
#  Forward declaration of MakeSU4HomomGeneral
U4pIdentify@:=function(group,p)
local 
   A_7,F,Print,apsu,c9,d,d_cyc,extra,extra1,extra2,factor,gens,group,grps,gu,
   homom,i,l3_4,mat,max,maximals,ominus,oplus,out_invol,phi,psu,sl27,soc,sp,su,
   subfields,symp,type,u4_2,x,z;
  max:=ValueOption("max");
  if max=fail then
    max:=true;
  fi;
  Print:=ValueOption("Print");
  if Print=fail then
    Print:=0;
  fi;
  Assert(1,IsPrimeInt(p));
  Assert(1,p > 2);
  if Print > 1 then
    Info(InfoWarning,1,"making standard group");
  fi;
  gu:=GU(4,p);
  su:=SU(4,p);
  apsu:=PGammaU(4,p);
  factor:=GroupHomomorphismByImages(gu,apsu,
    GeneratorsOfGroup(gu),List([1..Ngens(gu)],i->apsu.i));
  psu:=su@factor;
  if Print > 1 then
    Info(InfoWarning,1,"setting up isomorphism");
  fi;
  # =v= MULTIASSIGN =v=
  group:=MakeSU4HomomGeneral@(group,p,1,psu,apsu,factor:Print:=Print);
  homom:=group.val1;
  soc:=group.val2;
  group:=group.val3;
  # =^= MULTIASSIGN =^=
  if Print > 1 then
    Print("Calling FPGroupStrong");
  fi;
  # =v= MULTIASSIGN =v=
  phi:=FPGroupStrong(SubStructure(psu,List([1..Ngens(soc)],i->soc.i@homom)));
  F:=phi.val1;
  phi:=phi.val2;
  # =^= MULTIASSIGN =^=
  if (p+1) mod 2=0 then
    gens:=[homom(group.1),homom(group.2),apsu.1,apsu.3];
  else
    gens:=[homom(group.1),homom(group.2),apsu.3];
  fi;
  apsu:=SubStructure(apsu,gens);
  maximals:=[];
  if not max then
    return rec(val1:=homom,
      val2:=apsu,
      val3:=maximals,
      val4:=F,
      val5:=phi);
  fi;
  d:=Gcd(p+1,4);
  # =v= MULTIASSIGN =v=
  type:=WhichGroup@(group,p,1);
  soc:=type.val1;
  type:=type.val2;
  # =^= MULTIASSIGN =^=
  if Print > 1 then
    Print("type =",type);
  fi;
  z:=PrimitiveElement(GF(p^2));
  if not type in Set(["aut","pgu"]) then
    d_cyc:=(DiagonalMat([z,1,1,z^-p]) #CAST GL(4,p^2)
      )@factor;
    if type="psigmau" and d=4 then
      out_invol:=OuterInvol@(group,soc)@homom;
    fi;
  fi;
  if Print > 1 then
    Info(InfoWarning,1,"getting reducibles");
  fi;
  #  Append(~maximals, Stabiliser(psu, 1));
  Add(maximals,IsotropKStab@(4,p,1)@factor);
  Add(maximals,IsotropKStab@(4,p,2)@factor);
  Add(maximals,NonisotropKStab@(4,p,1)@factor);
  if Print > 1 then
    Info(InfoWarning,1,"getting imprimitives");
  fi;
  Add(maximals,StandardUnitImps@(4,p,2)@factor);
  if p > 3 or type in Set(["pgu","psu.2_3","psu.2_13","aut"]) then
    #  NOVELTY!!
    Add(maximals,StandardUnitImps@(4,p,1)@factor);
    Add(maximals,UnitImpHalfDim@(4,p)@factor);
  fi;
  if d=2 then
    #  p = 1 mod 4.
    #  no possibility for subgrp_copies to be greater than d.
    if Print > 1 then
      Info(InfoWarning,1,"getting subfields");
    fi;
    if type in Set(["psu","psigmau"]) then
      symp:=SpInSU@(4,p);
      Add(maximals,symp@factor);
      Add(maximals,(symp@factor)^d_cyc);
    fi;
    # =v= MULTIASSIGN =v=
    ominus:=OrthsInSU@(4,p);
    oplus:=ominus.val1;
    ominus:=ominus.val2;
    # =^= MULTIASSIGN =^=
    Add(maximals,oplus@factor);
    Add(maximals,ominus@factor);
  else
    #  (p+1, 4) = 4.
    if Print > 1 then
      Info(InfoWarning,1,"getting subfields");
    fi;
    subfields:=[];
    # =v= MULTIASSIGN =v=
    ominus:=OrthsInSU@(4,p);
    oplus:=ominus.val1;
    ominus:=ominus.val2;
    # =^= MULTIASSIGN =^=
    sp:=SpInSU@(4,p);
    if type in Set(["psu","psu.2_1"]) then
      if p > 3 then
        subfields:=[sp,oplus,ominus];
      else
        subfields:=[sp,ominus];
      fi;
    elif type in Set(["psigmau","psu.2_12"]) then
      if p > 3 then
        subfields:=[sp,oplus];
      else
        subfields:=[sp];
      fi;
    elif type in Set(["psu.2_3","psu.2_13"]) then
      subfields:=[ominus];
    fi;
    if Size(subfields) > 0 then
      for x in subfields do
        Add(maximals,x@factor);
        Add(maximals,(x@factor)^d_cyc);
      od;
    fi;
  fi;
  if d=4 then
    if p mod 8=7 and type in Set(["psu","psigmau"]) then
      if Print > 1 then
        Info(InfoWarning,1,"getting extraspecials");
      fi;
      extra:=NormaliserOfSymplecticGroup@(4,p^2);
      mat:=ConjIntoSU@(extra,4,p);
      extra:=extra^mat;
      if type="psu" then
        for i in [0..3] do
          Add(maximals,(extra@factor)^(d_cyc^i));
        od;
      else
        #  we should get 2 copies selected out of the 4 possibles.
        grps:=SelectGroupGeneral@(psu,extra@factor,d_cyc,out_invol);
        maximals:=Concatenation(maximals,[grps,grps^(d_cyc^2)]);
      fi;
    elif p mod 8=3 and type in Set(["psu","psu.2_1","psigmau","psu.2_12"]) then
      if Print > 1 then
        Info(InfoWarning,1,"getting extraspecials");
      fi;
      extra1:=NormaliserOfSymplecticGroup@(4,p^2);
      extra2:=DerivedSubgroup(extra1);
      mat:=ConjIntoSU@(extra2,4,p);
      extra:=extra2^mat;
      Add(maximals,extra@factor);
      Add(maximals,(extra@factor)^d_cyc);
    fi;
  fi;
  if d=2 and type in Set(["psu","psigmau","psu.2_3"]) then
    if (p mod 7) in Set([3,5,6]) and type in Set(["psu","psigmau"]) then
      if Print > 1 then
        Info(InfoWarning,1,"getting A_7");
      fi;
      A_7:=A7@(p);
      Add(maximals,A_7@factor);
      Add(maximals,(A_7@factor)^d_cyc);
    fi;
    if ((p mod 7) in Set([3,5,6])) and ((p mod 8)=1) and (type="psigmau") then
      if Print > 1 then
        Info(InfoWarning,1,"getting 2L_2(7) novelty");
      fi;
      sl27:=Getsl27d4@(p);
      Add(maximals,sl27@factor);
      Add(maximals,(sl27@factor)^d_cyc);
    elif ((p mod 7) in Set([3,5,6])) and ((p mod 8)=5) and (type="psu.2_3") 
       then
      if Print > 1 then
        Info(InfoWarning,1,"getting 2L_2(7) novelty");
      fi;
      sl27:=Getsl27d4@(p);
      Add(maximals,sl27@factor);
      Add(maximals,(sl27@factor)^d_cyc);
    fi;
    if (p mod 6)=5 and not (type="psu.2_3") then
      if Print > 1 then
        Info(InfoWarning,1,"getting U4_2");
      fi;
      u4_2:=U4_2@(p);
      Add(maximals,u4_2@factor);
      Add(maximals,(u4_2@factor)^d_cyc);
    fi;
  elif d=4 then
    if type in Set(["psu","psigmau"]) then
      c9:=[];
      if (p mod 7) in Set([3,5,6]) then
        if Print > 1 then
          Info(InfoWarning,1,"getting a7");
        fi;
        c9:=[A7@(p)];
      fi;
      if (p mod 6)=5 then
        if Print > 1 then
          Info(InfoWarning,1,"getting u4_2");
        fi;
        Add(c9,U4_2@(p));
      fi;
      if Size(c9) > 0 then
        for x in c9 do
          if type="psu" then
            for i in [0..3] do
              Add(maximals,(x@factor)^(d_cyc^i));
            od;
          else
            #  type eq "psigmau";
            grps:=SelectGroupGeneral@(psu,x@factor,d_cyc,out_invol);
            maximals:=Concatenation(maximals,[grps,grps^(d_cyc^2)]);
          fi;
        od;
      fi;
    fi;
    if (p mod 7) in Set([3,5,6]) and (p > 3) and type in 
       Set(["psigmau","psu.2_3"]) then
      if ((p mod 8)=3 and type="psigmau") or ((p mod 8)=7 and type="psu.2_3") 
         then
        if Print > 1 then
          Info(InfoWarning,1,"getting novelty SL_2(7)");
        fi;
        c9:=Getsl27d4@(p);
        grps:=SelectGroupGeneral@(psu,c9@factor,d_cyc,out_invol);
        maximals:=Concatenation(maximals,[grps,grps^(d_cyc^2)]);
      fi;
    fi;
    if p=3 and type in Set(["psu","psu.2_1","psu.2_3","psu.2_13"]) then
      if Print > 1 then
        Info(InfoWarning,1,"getting L_3(4)");
      fi;
      l3_4:=L3_4@();
      Add(maximals,l3_4@factor);
      Add(maximals,(l3_4@factor)^d_cyc);
    fi;
  fi;
  return rec(val1:=homom,
    val2:=apsu,
    val3:=maximals,
    val4:=F,
    val5:=phi);
end;
;
#  *******************************************************************
InstallGlobalFunction(U4qIdentify@,
function(group,q)
local 
   F,Print,apsu,d,d_cyc,e,f,fac,fac_e,factor,gens,group,grp,gu,homom,max,
   maximals,ominus,oplus,p,phi,psu,soc,sp,su,subfields,type,x,z;
  max:=ValueOption("max");
  if max=fail then
    max:=true;
  fi;
  Print:=ValueOption("Print");
  if Print=fail then
    Print:=0;
  fi;
  fac:=CollectedFactors(q);
  Assert(1,Size(fac)=1);
  p:=fac[1][1];
  e:=fac[1][2];
  Assert(1,IsEvenInt(e) or e=1 or IsEvenInt(p));
  if e=1 then
    return U4pIdentify@(group,q:max:=max,Print:=Print);
  fi;
  if Print > 1 then
    Info(InfoWarning,1,"making standard group");
  fi;
  gu:=GU(4,q);
  su:=SU(4,q);
  apsu:=PGammaU(4,q);
  factor:=GroupHomomorphismByImages(gu,apsu,
    GeneratorsOfGroup(gu),List([1..Ngens(gu)],i->apsu.i));
  psu:=su@factor;
  if Print > 1 then
    Info(InfoWarning,1,"setting up isomorphism");
  fi;
  # =v= MULTIASSIGN =v=
  group:=MakeSU4HomomGeneral@(group,p,e,psu,apsu,factor:Print:=Print);
  homom:=group.val1;
  soc:=group.val2;
  group:=group.val3;
  # =^= MULTIASSIGN =^=
  if Print > 1 then
    Print("Calling FPGroupStrong");
  fi;
  # =v= MULTIASSIGN =v=
  phi:=FPGroupStrong(SubStructure(psu,List([1..Ngens(soc)],i->soc.i@homom)));
  F:=phi.val1;
  phi:=phi.val2;
  # =^= MULTIASSIGN =^=
  if (q+1) mod 2=0 then
    gens:=[homom(group.1),homom(group.2),apsu.1,apsu.3];
  else
    gens:=[homom(group.1),homom(group.2),apsu.3];
  fi;
  apsu:=SubStructure(apsu,gens);
  maximals:=[];
  if not max then
    return rec(val1:=homom,
      val2:=apsu,
      val3:=maximals,
      val4:=F,
      val5:=phi);
  fi;
  d:=Gcd(q+1,4);
  # =v= MULTIASSIGN =v=
  type:=WhichGroup@(group,p,e);
  soc:=type.val1;
  type:=type.val2;
  # =^= MULTIASSIGN =^=
  if Print > 1 then
    Print("type =",type);
  fi;
  z:=PrimitiveElement(GF(q^2));
  if not type in Set(["aut","pgu"]) and IsOddInt(q) then
    d_cyc:=(DiagonalMat([z,1,1,z^-q]) #CAST GL(4,q^2)
      )@factor;
  fi;
  if Print > 1 then
    Info(InfoWarning,1,"getting reducibles");
  fi;
  Add(maximals,Stabiliser(psu,1));
  Add(maximals,IsotropKStab@(4,q,2)@factor);
  Add(maximals,NonisotropKStab@(4,q,1)@factor);
  if Print > 1 then
    Info(InfoWarning,1,"getting imprimitives");
  fi;
  Add(maximals,StandardUnitImps@(4,q,1)@factor);
  Add(maximals,StandardUnitImps@(4,q,2)@factor);
  Add(maximals,UnitImpHalfDim@(4,q)@factor);
  if Print > 1 then
    Info(InfoWarning,1,"getting subfields");
  fi;
  if e > 2 then
    fac_e:=CollectedFactors(e);
    if fac_e[1][1]=2 then
      fac_e:=Filtered(fac_e,x->not x=fac_e[1]);
    fi;
    for x in fac_e do
      f:=QuoInt(e,x[1]);
      grp:=SubfieldSU@(4,p,e,f);
      Add(maximals,grp@factor);
    od;
  fi;
  if d=1 then
    sp:=SpInSU@(4,q);
    Add(maximals,sp@factor);
  elif d=2 then
    if type in Set(["psu","psigmau"]) then
      sp:=SpInSU@(4,q);
      Add(maximals,sp@factor);
      Add(maximals,(sp@factor)^d_cyc);
    fi;
    # =v= MULTIASSIGN =v=
    ominus:=OrthsInSU@(4,q);
    oplus:=ominus.val1;
    ominus:=ominus.val2;
    # =^= MULTIASSIGN =^=
    Add(maximals,oplus@factor);
    Add(maximals,ominus@factor);
  else
    subfields:=[];
    if type in Set(["psu","twoorth+","twoorth-"]) then
      Add(subfields,SpInSU@(4,q));
      # =v= MULTIASSIGN =v=
      ominus:=OrthsInSU@(4,q);
      oplus:=ominus.val1;
      ominus:=ominus.val2;
      # =^= MULTIASSIGN =^=
      if type in Set(["psu","two_orth+"]) then
        Add(subfields,oplus);
      fi;
      if type in Set(["psu","two_orth-"]) then
        Add(subfields,ominus);
      fi;
      for x in subfields do
        Add(maximals,x@factor);
        Add(maximals,(x@factor)^d_cyc);
      od;
    fi;
  fi;
  return rec(val1:=homom,
    val2:=apsu,
    val3:=maximals,
    val4:=F,
    val5:=phi);
end);

InstallGlobalFunction(MakeSU4HomomGeneral@,
function(group,p,e,psu,apsu,factor)
local 
   CG,GtoSU,Print,SUtoG,ce,d,g,group,h,homom,i,imgens,ims,isc,j,mat,newgens,
   psugens,soc,socle,subgp,subsoc,works;
  Print:=ValueOption("Print");
  if Print=fail then
    Print:=0;
  fi;
  soc:=Socle(group);
  #   Reduce number of generators of soc, and
  #  * rearrange generators of group to get those of soc coming first
  
  d:=4;
  repeat
    newgens:=[Random(soc),Random(soc)];
    subsoc:=SubStructure(soc,newgens);
    RandomSchreier(subsoc);
    
  until subsoc=soc;
  #  
  #  while subsoc ne soc do
  #  x:=Random(soc);
  #  while x in subsoc do x:=Random(soc); end while;
  #  Append(~newgens,x); subsoc := sub<soc|newgens>; RandomSchreier(subsoc);
  #  end while;
  
  soc:=subsoc;
  subgp:=subsoc;
  for g in Generators(group) do
    if not g in subgp then
      Add(newgens,g);
      subgp:=SubStructure(group,newgens);
      RandomSchreier(subgp);
    fi;
  od;
  group:=subgp;
  works:=false;
  while not works do
    # =v= MULTIASSIGN =v=
    GtoSU:=RecogniseSU4(soc,p^e);
    works:=GtoSU.val1;
    GtoSU:=GtoSU.val2;
    # =^= MULTIASSIGN =^=
  od;
  psugens:=[];
  for i in [1..Ngens(soc)] do
    mat:=GtoSU(soc.i);
    Add(psugens,mat@factor);
  od;
  #  Now identify images of all generators of group in apsu.
  ims:=psugens;
  for i in [Ngens(soc)+1..Ngens(group)] do
    g:=group.i;
    CG:=apsu;
    ce:=One(apsu);
    for j in [1..Size(psugens)] do
      mat:=GtoSU(soc.j^g);
      # =v= MULTIASSIGN =v=
      h:=IsConjugate(CG,psugens[j]^ce,mat@factor);
      isc:=h.val1;
      h:=h.val2;
      # =^= MULTIASSIGN =^=
      if not isc then
        Error("Conjugation error in Aut(PSU(d,q))");
      fi;
      CG:=Centraliser(CG,mat@factor);
      ce:=ce*h;
    od;
    Add(ims,ce);
  od;
  return rec(val1:=GroupHomomorphismByImages(group,apsu,
    GeneratorsOfGroup(group),ims),
    val2:=soc,
    val3:=group);
end);


